Домашнее задание к занятию «SQL. Часть 1» Задание Огумцяна Арега 
Инструкция по выполнению домашних работ
Сделайте форк репозитория c шаблоном решения к себе на Github и переименуйте его по названию или номеру занятия, например, https://github.com/имя-вашего-репозитория/gitlab-hw или https://github.com/имя-вашего -репозитория/8-03-hw ).
Выполните клонирование этой репозитории к себе на ПК с помощью команды git clone.
Выполните домашнее задание и заполните локально этот файл README.md:
впишите вверху название занятий, вашу семью и имя;
в каждой заданной главе решение в требуемом виде: текст/код/скриншоты/ссылка;
для корректного добавления скриншотов воспользуйтесь инструкцией «Как вставить скриншот в шаблон с решением» ;
при оформлении викор возможности языка разметки md. Коротко об этом можно посмотреть в инструкции по MarkDown .
После завершения работы над домашним заданием сделайте коммит ( git commit -m "comment") и отредактируйте его на Github ( git push origin).
Для домашней проверки задания преподавателем в личном кабинете прикрепите и отредактируйте ссылку на решение в видео md-файле на Github.
Любые вопросы задавайте в чате учебной группы и/или в разделе «Вопросы по заданию» в личном кабинете.
Желаем успехов в выполнении домашних работ.

Задание можно калибровать как в любой IDE, так и в командной строке.

Задание 1
Получайте уникальные названия концов из таблиц с адресами, которые начинаются с «K» и заканчиваются на «a» и не содержат пробелов.

Решение 1
Для выполнения этого задания нужно найти все уникальные значения из столбца название конца (или аналогичного), которые соответствуют следующим условиям:
1. Начинаются с буквы 'K'.
2. Заканчиваются на букву 'a'.
3. Не содержат пробелов.
Предположим, у нас есть таблица с названием адреса, содержащая столбец название_конца. Тогда SQL-запрос для решения задачи будет выглядеть так:
SQL
SELECT DISTINCT название_конца
FROM адреса
WHERE название_конца LIKE 'K%a'
AND название_конца NOT LIKE '% %';
### Пояснение:
- LIKE 'K%a': выбираем строки, начинающиеся с 'K' и заканчивающиеся на 'a'. Символ % означает любое количество любых символов между ними.
- NOT LIKE '% %': исключаем строки, содержащие хотя бы один пробел.
- DISTINCT: используем для получения уникальных значений.

Задание 2
Возьмите таблицы денежных средств для проката фильмов по платежам, которые осуществлялись в период с 15 июня 2005 года по 18 июня 2005 года включительно, и стоимость их составляет 10,00.
Решение 2
Чтобы решить эту задачу, необходимо получить данные о платежах за прокат фильмов, которые были совершены в указанный временной промежуток (с 15 июня 2005 года по 18 июня 2005 года включительно) и имели точную сумму платежа 10,00.
Предположим, что у вас есть таблица с именем payments, которая содержит следующие поля:
- payment_date – дата платежа,
- amount – сумма платежа.
Тогда запрос может выглядеть следующим образом:
SQL
SELECT *
FROM payments
WHERE payment_date BETWEEN '2005-06-15' AND '2005-06-18'
  AND amount = 10.00;
Пояснения к запросу:
- BETWEEN '2005-06-15' AND '2005-06-18' – условие выбора платежей, сделанных в указанный диапазон дат (включительно).
- amount = 10.00 – условие отбора платежей, сумма которых точно равна 10,00.
Этот запрос вернет все записи из таблицы payments, соответствующие указанным критериям.

Задание 3
Получите последние пять фильмов в аренду.
Решение 3
Чтобы получить последние пять фильмов, взятых в аренду, нам потребуется отсортировать данные по дате аренды и выбрать самые свежие записи. Предположим, что у нас есть таблица rentals со следующими полями:
- film_id – идентификатор фильма,
- rental_date – дата аренды.
Запрос для получения последних пяти фильмов в аренду может выглядеть следующим образом:
SQL
SELECT film_id
FROM rentals
ORDER BY rental_date DESC
LIMIT 5;
Объяснение:
- ORDER BY rental_date DESC – сортируем записи по дате аренды в порядке убывания, чтобы самые поздние даты оказались вверху списка.
- LIMIT 5 – ограничиваем результат пятью строками, то есть получаем информацию о последних пяти фильмах, взятых в аренду.
Таким образом, этот запрос вернет идентификаторы (film_id) последних пяти фильмов, которые были арендованы.

Задание 4
Один запрос позволяет получить имена активных покупателей, таких как Келли или Вилли.

Сформируйте вывод таким образом:

все буквы в фамилиях и имени из верхнего регистра переводятся в нижний регистр,
замените буквы «ll» в именах на «pp».
Решение 4
Для того чтобы выполнить данное задание, предположим, что у нас есть таблица customers с двумя полями: first_name (имя покупателя) и last_name (фамилия покупателя). Нам нужно вывести имена активных покупателей, таких как Келли или Вилли, при этом преобразовать все буквы в нижнем регистре и заменить буквы «ll» на «pp».
Запрос будет выглядеть следующим образом:
SQL
SELECT LOWER(REPLACE(first_name, 'll', 'pp')) AS first_name,
       LOWER(last_name) AS last_name
FROM customers
WHERE first_name IN ('Келли', 'Вилли');
### Объяснение:
1. LOWER(): Эта функция преобразует все символы в строке в нижний регистр.
2. REPLACE(): Функция заменяет одну подстроку другой. В данном случае мы заменяем «ll» на «pp» в именах.
3. IN ('Келли', 'Вилли'): Условие фильтрации выбирает только тех покупателей, чьи имена совпадают с указанными значениями.
Таким образом, данный запрос выполнит все необходимые преобразования и отфильтрует нужных покупателей.
